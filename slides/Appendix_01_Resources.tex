%% This file was auto-generated by IPython, do NOT edit
%% Conversion from the original notebook file:
%% Appendix_01_Resources.ipynb
%%
\documentclass[11pt,english]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% Use and configure listings package for nicely formatted code
\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter 
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother 

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy

\begin{document}

\section{Python in HPC}


\subsection{Supercomputing 2012}

Presenters:


\noindent {\bf Andy R. Terrel, PhD}\\
Texas Advanced Computing Center\\
University of
Texas at Austin\\[2em]

\noindent {\bf Travis Oliphant, PhD}\\
Continuum Analytics\\[2em]

\noindent {\bf Aron Ahmadia, PhD}\\
Supercomputing Laboratory\\
King Abdullah University of Science and Technoglogy\\[2em]
\begin{center}

\href{http://creativecommons.org/licenses/by/3.0/deed.en\_US}{\includegraphics{figures/creative_commons_logo.png}}\\[2em]

\noindent Python in HPC Tutorial by Terrel, Oliphant, and Ahmadia is licensed
under a Creative Commons Attribution 3.0 Unported License. \\[2em]

\href{http://www.tacc.utexas.edu}{\includegraphics[scale=0.8]{figures/TACC_logo.png}} \qquad
\href{http://www.continuum.io}{\includegraphics[scale=.3]{figures/continuum.png}} \qquad
\href{http://www.kaust.edu.sa/}{\includegraphics[scale=.3]{figures/kaust.png}}
\end{center}

\newpage

\subsection{Updated Tutorial}

These presentation materials are being continuously updated as we refine
and improve our demonstrats. To get the latest version of this tutorial
you can:

\begin{enumerate}[1)]
\item
  Download a zip or tar ball from the
  \href{https://github.com/aterrel/HPCPythonSC2012/tags}{github SC2012
  tag}:

  wget --no-check-certificate
  https://github.com/aterrel/HPCPythonSC2012/zipball/SC2012
\item
  Checkout from git

  git clone https://github.com/aterrel/HPCPythonSC2012.git
\item
  View the html version on
  \href{http://nbviewer.ipython.org/urls/raw.github.com/aterrel/HPCPythonSC2012/master/Appendix_01_Resources.ipynb}{nbviewer}.
\item
  As a last resort, head to https://github.com/aterrel/HPCPythonSC2012
  for updated instructions (see the README at the bottom of the page).
\end{enumerate}

\newpage
\subsection{Learning Python}

There are a very large number of resources for learning the python
language. The issue of course is finding a resource that is attractive
to the correct mindset. Very often something that a programmer is able
to learn from has little resonance with an artist. For this reason, I am
going to list off a couple of places that I find particularly good, but
of course I have been programming for over a decade.

While learning the language is important, the real value of Python is
the numerous libraries and the community around the tools. With that
said finding what your particular community is doing is pretty
important, but there are a core set of tools that are used by most
pythonistas. I list off a few of these tools for your consumption.

Also, because we like to see what people are doing with python, I list
off a few shining examples of python in the wide world of scientific
computing. I have to admit that there are a huge number of possibilities
but few in the realm of HPC. At the very least, a HPC person should know
Python for its scripting abilities but as the other sections of this
document underscore, Python is a good candidate for HPC codes as well.

\subsubsection{Python Tutorials}

\begin{itemize}
\item
  \textbf{\href{http://docs.python.org/tutorial/}{Python Doc Tutorial}}:
  This is the tutorial written by the developers of Python, best for
  programmers.
\item
  \textbf{\href{http://www.greenteapress.com/thinkpython/}{Think
  Python}}: A book for non-programmers.
\end{itemize}

\subsubsection{Python Tools}

\begin{itemize}
\item
  \textbf{\href{http://www.enthought.com/products/epd.php}{Enthought
  Python Distribution}}: A distribution of the most commonly used tools
  by the community (free for academics).
\item
  \textbf{\href{http://numpy.scipy.org/}{NumPy}}: Fast array library for
  Python.
\item
  \textbf{\href{http://scipy.org}{SciPy}}: A collection of scientific
  libraries.
\item
  \textbf{\href{http://matplotlib.sourceforge.net/}{MatPlotLib}}: A
  highly customizable 2D plotting library
\item
  \textbf{\href{http://ipython.org/}{IPython}}: An interactive Python
  shell and parallel code manager. The IPython notebook has become very
  popular and allows users to use an interface similar to Mathematica on
  a supercomputer.
\end{itemize}

\subsubsection{Python Stories}

\begin{itemize}
\item
  \textbf{\href{http://conference.scipy.org/}{SciPy Conferences}}: The
  series of conferences associated with the scientific Python community
  see recent videos at
  \href{http://www.youtube.com/user/NextDayVideo/videos?flow=grid\&view=0}{Next
  Day Video Youtube Channel} or \href{http://pyvideo.org}{PyVideo}.
\item
  \textbf{\href{http://www.youtube.com/watch?v=mLuIB8aW2KA\&feature=youtu.be}{Python
  in Astronomy}}: Joshua Bloom from UC Berkeley gave a keynote talk at
  SciPy 2012 on ``Python as Super Glue for the Modern Scientific
  Workflow''
\item
  \textbf{\href{http://numfocus.org/user-stories/}{NumFocus User
  Stories}}: A foundation for scientific computing tools with a growing
  number of user stories.
\item
  \textbf{\href{http://numerics.kaust.edu.sa/papers/pyclaw-sisc/pyclaw-sisc.html}{PyCLAW}}:
  A petascale application written in Python
\end{itemize}

\newpage
\subsection{Performance}

Despite all the great features outlined above, the (mis)perception is
that Python is too slow for HPC Development. While it is true that
Python might not be the best language to write your tight loop and
expect a high percentage of peak flop rate, it turns out that Python has
a number of tools to help switch those lower-level languages.

To discuss performance I outline three sets of tools: profiling,
speeding up the python code via c, and speeding up python via python. It
is my view that Python has some of the best tools for looking at what
your code's performance is then drilling down to the actual bottle
necks. Speeding up code without profiling is about like trying to kill a
deer with an uzi.

\subsubsection{Python tools for profiling}

\begin{itemize}
\item
  \textbf{\href{http://docs.python.org/library/profile.html}{profile and
  cProfile modules}}: These modules will give you your standard run time
  analysis and function call stack. It is pretty nice to save their
  statistics and using the pstats module you can look at the data in a
  number of ways.
\item
  \textbf{\href{http://packages.python.org/line\_profiler/}{kernprof}}:
  this tool puts together many routines for doing things like line by
  line code timing
\item
  \textbf{\href{http://pypi.python.org/pypi/memory\_profiler}{memory\_profiler}}:
  this tool produces line by line memory foot print of your code.
\item
  \textbf{\href{http://ipython.org/ipython-doc/dev/interactive/tutorial.html\#magic-functions}{IPython
  timers}}: The \texttt{timeit} function is quite nice for seeing the
  differences in functions in a quick interactive way.
\end{itemize}

\subsubsection{Speeding up Python}

\begin{itemize}
\item
  \textbf{\href{http://cython.org/}{Cython}}: cython is the quickest way
  to take a few functions in python and get faster code. You can
  decorate the function with the cython variant of python and it
  generates c code. This is very maintable and can also link to other
  hand written code in c/c++/fortran quite easily. It is by far the
  preferred tool today.
\item
  \textbf{\href{http://docs.python.org/library/ctypes.html}{ctypes}}:
  ctypes will allow you to write your functions in c and then wrap them
  quickly with its simple decoration of the code. It handles all the
  pain of casting from PyObjects and managing the gil to call the c
  function.
\end{itemize}

Other approaches exist for writing your code in C but they are all
somewhat more for taking a C/C++ library and wrapping it in Python.

\subsubsection{Python-only approaches}

If you want to stay inside Python mostly, my advice is to figure out
what data you are using and picking correct data types for implementing
your algorithms. It has been my experience that you will usually get
much farther by optimizing your data structures then any low level c
hack. For example:

\begin{itemize}
\item
  \textbf{\href{http://numpy.scipy.org/}{numpy}}: a contingous array
  very fast for strided operations of arrays
\item
  \textbf{\href{http://code.google.com/p/numexpr/}{numexpr}}: a numpy
  array expression optimizer. It allows for multithreading numpy array
  expressions and also gets rid of the numerous temporaries numpy makes
  because of restrictions of the Python interpreter.
\item
  \textbf{\href{http://pypi.python.org/pypi/blist}{blist}}: a b-tree
  implementation of a list, very fast for inserting, indexing, and
  moving the internal nodes of a list
\item
  \textbf{\href{http://pandas.pydata.org/}{pandas}}: data frames (or
  tables) very fast analytics on the arrays.
\item
  \textbf{\href{http://www.pytables.org/moin}{pytables}}: fast
  structured hierarchical tables (like hdf5), especially good for out of
  core calculations and queries to large data.
\end{itemize}

\newpage
\subsection{Scaling Python}

Right now there are a few distributed Python tools but the list is
growing rapidly. Here I just give a list the tools and some domain tools
that are used in HPC that provide a Python interface.

\subsubsection{Distibuted computing libraries}

\begin{itemize}
\item
  \textbf{\href{http://mpi4py.scipy.org/}{mpi4py}}: Fastest most
  complete mpi python wrapper.
\item
  \textbf{\href{http://discoproject.org/}{disco}}: Python Hadoop-like
  framework.
\item
  \textbf{\href{http://ipython.org/ipython-doc/dev/parallel/index.html}{IPython
  Parallel}}: A mpi or zero-mq based parallel python.
\item
  \textbf{\href{http://dev.danse.us/trac/pathos}{pathos}}: framework for
  heterogeneous computing
\end{itemize}

\subsubsection{Domain specific libraries}

\begin{itemize}
\item
  \textbf{\href{http://code.google.com/p/petsc4py/}{petsc4py}}: Python
  bindings for PETSc, the Portable, Extensible Toolkit for Scientific
  Computation.
\item
  \textbf{\href{http://slepc4py.googlecode.com/}{slepc4py}}: Python
  bindings for SLEPc, the Scalable Library for Eigenvalue Problem
  Computations.
\item
  \textbf{\href{http://tao4py.googlecode.com/}{tao4py}}: Python bindings
  for TAO, the Toolkit for Advanced Optimization.
\item
  \textbf{\href{http://trilinos.sandia.gov/packages/pytrilinos/}{pyTrilinos}}:
  Trilinos wrappers
\end{itemize}

\end{document}
